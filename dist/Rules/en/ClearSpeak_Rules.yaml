---
-
   include: "common-rules.yaml"


-
   name: default
   tag: msqrt
   match: "."
   replace: 
    - test: 
         if: "$Verbosity!='Terse'"
         then: {t: the}
    - test: 
         if: $ClearSpeak_Roots = 'PosNegSqRoot' or $ClearSpeak_Roots = 'PosNegSqRootEnd'
         then_test: 
            if: parent::*[self::m:mrow and count(*)=2 and *[1][self::m:mo][text()='-']]
            then: {t: negative}
            else: {t: positive}
    - t: square root
    - test: 
         if: "$Verbosity!='Terse'"
         then: {t: of}
         else: {pause: short}
    - x: "*[1]"
    - test: 
       - if: $ClearSpeak_Roots = 'EndRoot' or $ClearSpeak_Roots = 'PosNegSqRootEnd'
         then:
            - pause: short
            - t: end root
            - pause: medium
       - else_if: IsNode(*[1], 'simple')
         then: [pause: short]
         else: [pause: long]

-
   name: default
   tag: mroot
   match: "."
   replace: 
      - test: 
         if: "$Verbosity!='Terse'"
         then: {t: the}
      - test: 
         if: $ClearSpeak_Roots = 'PosNegSqRoot' or $ClearSpeak_Roots = 'PosNegSqRootEnd'
         then_test: 
            if: parent::*[self::m:mrow and count(*)=2 and *[1][self::m:mo][text()='-']]
            then: {t: negative}
            else: {t: positive}
      - test:
         if: "*[2][self::m:mn]"
         then_test:
            - if: "*[2][text()='2']"
              then: {t: square root}
            - else_if: "*[2][text()='3']"
              then: {t: cube root}
            - else_if: "*[2][not(contains(., '.'))]"
              then: [x: "ToOrdinal(*[2])", t: root]
         else:
            - test:
               if: "*[2][self::m:mi][string-length(.)=1]"
               then: [x: "*[2]", ct: "-th"]
               else: {x: "*[2]"}
            - t: root
      - test: 
            if: "$Verbosity!='Terse'"
            then: {t: of}
      - x: "*[1]"
      - test: 
         if: $ClearSpeak_Roots = 'EndRoot' or $ClearSpeak_Roots = 'PosNegSqRootEnd'
         then:
            - pause: short
            - t: end root
            - pause: medium
         else_test:
            if: IsNode(*[1], 'simple')
            then: [pause: short]
            else: [pause: long]
  
               
# The 'negative' rule interacts with the msqrt/mroot rules as those might pick off this case ("the negative square root of x")
-
   name: negative
   tag: mrow
   match: "count(*)=2 and *[1][self::m:mo][text()='-' or text()='+']"
   replace:
      - test:
         if:
            - "*[2][self::m:msqrt or self::m:mroot] and"
            - "($ClearSpeak_Roots = 'PosNegSqRoot' or $ClearSpeak_Roots = 'PosNegSqRootEnd')"
         then: {t: ""}
         else_test:
            if: "*[1][text()='-']"
            then: {t: negative}
            else: {t: positive}
      - x: "*[2]"
               
# Fraction rules
# Mixed numbers mostly "just work" because the invisible char reads as "and" and other parts read properly on their own
-
   name: common-fraction
   tag: mfrac
   match:
      - "*[1][self::m:mn][not(contains(., '.')) and text()<20]   and" 
      - "*[2][self::m:mn][not(contains(., '.')) and 2<= text() and text()<=10]"
   replace: [x: ToCommonFraction(.)]
-
   name: common-fraction-mixed-number
   tag: mfrac
   match:
      - "preceding-sibling::*[1][self::m:mo][text()='\u2064'] and" # preceding element is invisible plus
      - "*[1][self::m:mn][not(contains(., '.'))]   and" 
      - "*[2][self::m:mn][not(contains(., '.'))]"
   replace: [x: ToCommonFraction(.)]
-
   name: fraction-over-simple
   tag: mfrac
   match: "(IsNode(*[1],'simple') and IsNode(*[2],'simple'))"  # simple fraction in ClearSpeak spec
   replace: 
    - x: "*[1]"
    - t: over
    - x: "*[2]"
-
   # fraction with text or numbers followed by text in both numerator and denominator
   name: fraction-over-text
   tag: mfrac
   match:
      - "( "
      - "  ((*[1][self::m:mi or self::m:mtext][string-length(.)>1]) or " # fractions with text
      - "   (*[1][self::m:mrow][count(*)=3][ "
      - "        *[1][self::m:mn] and "
      - "        *[2][self::m:mo][text()='\u2062'] and "            # invisible times
      - "        *[3][self::m:mi or self::m:mtext][string-length(.)>1] ]) ) and"
      - "  ((*[2][self::m:mi or self::m:mtext][string-length(.)>1]) or " # fractions with text
      - "   (*[2][self::m:mrow][count(*)=3][ "
      - "        *[1][self::m:mn] and "
      - "        *[2][self::m:mo][text()='\u2062'] and "            # invisible times
      - "        *[3][self::m:mi or self::m:mtext][string-length(.)>1] ]) )"
      - ")"
   replace: 
    - x: "*[1]"
    - t: over
    - x: "*[2]"
-
   name: default
   tag: mfrac
   match: "."
   replace: 
    - ot: the
    - t: fraction with numerator
    - test:
       if: not(IsNode(*[1], 'simple'))
       then: {pause: medium}
    - x: "*[1]"
    - pause: medium
    - t: and denominator
    - x: "*[2]"
    - pause: long


# rules for functions raised to a power
# these could have been written on 'mrow' but putting them on msup seems more specific
# to see if it is a function, we look right to see if the following sibling is apply-function
-
   name: function-inverse
   tag: msup
   match:
    - "*[2][self::m:mrow][count(*)=2] and"                        # exponent is an mrow with children...
    - "*[2]/*[1][self::m:mo][text()='-'] and"                     #   '-'
    - "*[2]/*[2][self::m:mn][text()=1] and"                       #  and '1'
    - "*[1][self::m:mi] and IsNode(*[1], 'trig_name') and"        # base is a trig function name (e.g, sin, sinh)
    - "following-sibling::*[1][self::m:mo][text()='\u2061']"      # and msup is followed by invisible function apply
   replace:
      - test:
         if: $ClearSpeak_Trig = 'TrigInverse'
         then: [x: "*[1]", t: inverse]
         else_test:
            if: $ClearSpeak_Trig = 'ArcTrig'
            then: [t: arc, x: "*[1]"]
            else: [t: inverse, x: "*[1]"]       # default/Auto

-
   name: simple-integer
   tag: msup
   match: "*[2][self::m:mn][not(contains(., '.'))]"
   replace: 
    - x: "*[1]"
    - t: to the
    - test: 
         if: "*[2][.>0]"
         then: {x: "ToOrdinal(*[2])"}
         else: {x: "*[2]"}
    - t: power
-
   name: simple-negative-integer
   tag: msup
   match: 
    - "*[2][self::m:mrow][count(*)=2]"
    - "[*[1][self::m:mo][text()='-'] and"
    - "*[2][self::m:mn][not(contains(., '.'))]]"
   replace: 
    - x: "*[1]"
    - t: to the
    - x: "*[2]"
    - t: power
-
   name: simple-var
   tag: msup
   match: "*[2][self::m:mi][string-length(.)=1]"
   replace: 
    - x: "*[1]"
    - t: to the
    - x: "*[2]"
    - ct: "-th power"


-
   # match nested exponent, where the nested exponent is has the power 2 or 3 (n below)
   #   [xxx]^n, - [xxx]^n, [xxx] var^n, -[xxx] var^n
   # where xxx is a number, variable, or common fraction
   # short of creating a specialized built-in function, I don't see a way to eliminate a lot of repetition in the matches
   # also really bad is that the test of a common fraction is replicated here (four times!)
   name: nested-squared-or-cubed
   tag: msup
   match:
    - "*[2][self::m:msup]["
    - "     *[2][self::m:mn][text()='2' or text()='3'] and "  # exp is 2 or 3
    - ""    # base is mn, mi, common fraction ([xxx] case)
    - "     *[1][self::m:mn or self::m:mi or "
    - "          self::m:mfrac[*[1][self::m:mn][not(contains(., '.')) and text()<20]   and" 
    - "                        *[2][self::m:mn][not(contains(., '.')) and 2<= text() and text()<=10]]"
    - "         ]"
    - "    ]"
   replace: 
    - x: "*[1]"
    - t: raised to the
    - x: "*[2]"
    - t: power
-
   name: nested-negative-squared-or-cubed  # - [xxx]^n
   tag: msup
   match:
    - " *[2][self::m:mrow][count(*)=2][ "
    - "      *[1][self::m:mo][text()='-'] and "
    - "      *[2][self::m:msup]["
    - "           *[2][self::m:mn][text()='2' or text()='3'] and "  # exp is 2 or 3"
    - "           *[1][self::m:mn or self::m:mi or "
    - "                self::m:mfrac[*[1][self::m:mn][not(contains(., '.')) and text()<20]   and" 
    - "                              *[2][self::m:mn][not(contains(., '.')) and 2<= text() and text()<=10]]"
    - "               ]"
    - "          ]"
    - "     ]"
   replace: 
    - x: "*[1]"
    - t: raised to the
    - x: "*[2]"
    - t: power
-
   name: nested-var-squared-or-cubed  # [xxx] var^n
   tag: msup
   match:
    - "  *[2][self::m:mrow][count(*)=3][ "
    - "       *[3][self::m:msup]["
    - "            *[2][self::m:mn][text()='2' or text()='3'] and "  # exp is 2 or 3
    - "            *[1][self::m:mi]"
    - "           ] and "
    - "       *[2][self::m:mo][text()='\u2062'] and "     # invisible times
    - "       *[1][self::m:mn or self::m:mi or "
    - "            self::m:mfrac[*[1][self::m:mn][not(contains(., '.')) and text()<20]   and" 
    - "                          *[2][self::m:mn][not(contains(., '.')) and 2<= text() and text()<=10]]"
    - "           ]"
    - "      ]"
   replace: 
    - x: "*[1]"
    - t: raised to the
    - x: "*[2]"
    - t: power
-
   name: nested-negative-var-squared-or-cubed  # -[xxx] var^n
   tag: msup
   match:
    - "  *[2][self::m:mrow][count(*)=3][ "
    - "       *[3][self::m:msup]["
    - "            *[2][self::m:mn][text()='2' or text()='3'] and "  # exp is 2 or 3
    - "            *[1][self::m:mi]"
    - "           ] and "
    - "       *[2][self::m:mo][text()='\u2062'] and "     # invisible times
    - "       *[1][self::m:mrow][count(*)=2][ "
    - "            *[1][self::m:mo][text()='-'] and "
    - "            *[2][self::m:mn or self::m:mi or "
    - "                 self::m:mfrac[*[1][self::m:mn][not(contains(., '.')) and text()<20]   and" 
    - "                               *[2][self::m:mn][not(contains(., '.')) and 2<= text() and text()<=10]]"
    - "                ]"
    - "           ]"
    - "      ]"
   replace: 
    - x: "*[1]"
    - t: raised to the
    - x: "*[2]"
    - t: power
-
   name: default-exponent-power
   tag: msup
   match:  # directly a superscript or an mrow that contains a superscript
    - "*[2][self::m:msup or "
    - "     self::m:mrow[m:msup]"
    - "    ]"
   replace: 
    - x: "*[1]"
    - t: raised to the exponent
    - pause: short
    - x: "*[2]"
    - pause: short
    - t: end exponent
-
   name: default
   tag: msup
   match: "."
   replace: 
    - x: "*[1]"
    - t: raised to the
    - x: "*[2]"
    - t: power

#
# Some rules on mrows
#
-
   name: absolute-value
   tag: mrow
   match: "count(*)=3 and not(*[2][self::m:mtable]) and IsBracketed(., '|', '|')"
   replace: 
   - test: 
      if: "$Verbosity!='Terse'"
      then: {t: the}
   - t: absolute value of 
   - x: "*[2]"

-
   name: set
   tag: mrow
   match: "IsBracketed(., '{', '}')"
   replace: 
   - test: 
       - if: "count(*)=2"
         then:
            - test: 
               if: "$Verbosity!='Terse'"
               then: {t: the}
            - t: empty set
       - else_if: "count(*[2]/*)=3 and *[2]/*[2][self::m:mo][text()=':' or text()='|']"
         then:
            - test: 
               if: "$Verbosity!='Terse'"
               then: {t: the}
            - t: set of
            - test:
               if: $ClearSpeak_Sets != 'woAll'
               then: [t: all]
            - x: "*[2]/*[1]"
            - t: such that
            - x: "*[2]/*[3]"
         else:
            - test: 
               if: $ClearSpeak_Sets != 'SilentBracket'
               then:
                  - test: 
                     if: "$Verbosity!='Terse'"
                     then: {t: the}
                  - t: set
            - x: "*[2]"



-
# intervals are controlled by a ClearSpeak Preference -- parens/brackets don't have to match, so we avoid IsBracketed
# alternatively, we could have four (or ten) rules, but there is a lot of duplication if we do that
# this one rule handles all ten cases listed as part $ClearSpeak_Paren = 'Interval'
# note that *[2] is an mrow with X, ",", Y, so getting X or Y is a double index
   name: intervals
   variables:
   - is_intervals_start_infinity: "*[2]/*[1][*[1][text()='-'] and *[2][text()='∞']]"
   - is_intervals_end_infinity: "*[2]/*[3][text()='∞'or (*[1][text()='+'] and *[2][text()='∞'])]"
   tag: mrow
   match:
   - "count(*)=3 and $ClearSpeak_Paren = 'Interval' and"
   - "*[1][text()='(' or text()='['] and *[3][text()=')' or text()=']']"
   replace: 
   - t: the interval from
   - x: "*[2]/*[1]"
   - t: to
   - x: "*[2]/*[3]"
   - pause: short
   # logic to deal with [not] arg #1
   - test:
      if: "not($is_intervals_start_infinity)"
      then:
         - test:
            if: "*[1][text()='(']"
            then: [t: "not"]
         - t: "including"
         - x: "*[2]/*[1]"
   # some ugly logic dealing with connectives: or, but, but, and (cleaner to be part of next clause?)
   - test:
      if: "not($is_intervals_start_infinity or $is_intervals_end_infinity)"
      then_test:
          - if: "IsBracketed(., '(', ')')"
            then: [t: or]
          - else_if: "IsBracketed(., '[', ']')"
            then: [t: and]
            else: [t: but]
   # onto the [not] [including]... part
   - test:
      if: not($is_intervals_end_infinity)
      then:
         - test:
            # there is some asymmetry to the test because of the and/or/but logic above
            if: not( IsBracketed(., '(', ')') or IsBracketed(., '[', ']') ) or $is_intervals_start_infinity
            then: 
               - test:
                     if: "*[3][text()=')'] "
                     then: [t: "not"]
               - t: "including"
         - x: "*[2]/*[3]"

-
   name: binomial-frac-vector
   tag: mrow
   match:
   - "$ClearSpeak_Matrix = 'Combinatorics' and "
   - "IsBracketed(., '(', ')') and "
   - "*[2][self::m:mtable][count(*[1]/*)=1 and count(*)=2]"
   replace: 
   - x: "*[2]/*[1]/*[1]/*"   # mtable/mtr/mtd
   - t: choose
   - x: "*[2]/*[2]/*[1]/*"

#
# Matrix/Determinant rules
# matrix and determinant are the same other than "matrix"/"determinant" based on the bracketing chars
# the pausing logic is pushed down to the <mtd>
# the rules either speak the <mtr>s (to get "row n") or the <mtd>s. "column n" spoken if $IsColumnSilent is false
-
   name: 1x1-matrix
   tag: mrow
   variables: [IsColumnSilent: "true()"]
   match:
   - "*[2][self::m:mtable] and"
   - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
   - count(*[2]/*)=1 and count(*[2]/*[self::m:mtr][1]/*)=1
   replace:
    - ot: the
    - t: 1 by 1
    - test:
        if: "*[1][text()='|']"    # just need to check the first bracket since we know it must be (, [, or |
        then: {t: determinant}
        else: {t: matrix}
    - t: with entry
    - x: "*[2]/*[1]/*"

# simpler reading methods for smaller matrices if the entries are simple
-
  name: 2-or-3x1-matrix
  tag: mrow
  variables: [IsColumnSilent: true()]
  match:
    - "*[2][self::m:mtable] and"
    - "$ClearSpeak_Matrix != 'SpeakColNum' and "    # "simple" isn't used for this preference
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - count(*[2]/*[1]/*)=1 and    # one column
    - count(*[2]/*)<=3 and   # at least two rows
    - IsNode(*[2]/*/*/*,'simple')   # IsNode() returns true if all the nodes are simple
  replace: 
    - t: the
    - x: count(*[2]/*)
    - t: by 1 column
    - test:
        if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
        then: {t: vector}
        else: {t: matrix}
    - pause: long
    - x: "*[2]/*/*"
    - test:
        if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
        then:
         - t: "end"
         - test:
            if: $ClearSpeak_Matrix = 'EndVector'
            then: {t: vector}
            else: {t: matrix}

-
  name: default-column-matrix
  tag: mrow
  variables: [IsColumnSilent: true()]
  match:
    - "*[2][self::m:mtable] and"
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - count(*[2]/*[1]/*)=1
  replace: 
    - t: the
    - x: "count(*[2]/*)"
    - t: by 1 column
    - test:
        if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
        then: {t: vector}
        else: {t: matrix}
    - pause: long
    - x: "*[2]/*"     # select the rows (mtr)
    - test:
        if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
        then: [t: "end matrix"]
 
-
  name: 1x2-or-3-matrix
  tag: mrow
  variables: [IsColumnSilent: $ClearSpeak_Matrix != 'SpeakColNum']
  match:
    - "*[2][self::m:mtable] and"
    - "$ClearSpeak_Matrix != 'SpeakColNum' and "    # "simple" isn't used for this preference
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - count(*[2]/*)=1  and          # one row
    - count(*[2]/*[1]/*)<=3 and   # at least two cols
    - IsNode(*[2]/*/*/*,'simple')   # IsNode() returns true if all the nodes are simple
  replace: 
    - t: the 1 by
    - x: count(*[2]/*/*)
    - t: row
    - test:
        if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
        then: {t: vector}
        else: {t: matrix}
    - pause: long
    - x: "*[2]/*/*"
    - test:
        if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
        then:
         - t: "end"
         - test:
            if: $ClearSpeak_Matrix = 'EndMatrix'
            then: {t: matrix}
            else: {t: vector}
 
-
  name: default-row-matrix
  tag: mrow
  variables: [IsColumnSilent: "$ClearSpeak_Matrix = 'SilentColNum'"]
  match:
    - "*[2][self::m:mtable] and"
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - count(*[2]/*)=1         # one row
  replace: 
    - t: the 1 by
    - x: "count(*[2]/*/*)"
    - t: row
    - test:
        if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
        then: {t: vector}
        else: {t: matrix}
    - pause: long
    - pause: medium
    - x: "*[2]/*/*"     # select the cols (mtd)
    - test:
        if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
        then:
         - t: "end"
         - test:
            if: $ClearSpeak_Matrix = 'EndMatrix'
            then: {t: matrix}
            else: {t: vector}

-
  name: simple-small-matrix
  tag: mrow
  match:
    - "*[2][self::m:mtable] and"
    - "$ClearSpeak_Matrix != 'SpeakColNum' and "    # "simple" isn't used for this preference
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - (count(*[2]/*)<=3 and count(*[2]/*[1]/*)<=3) and       # no bigger than a 3x3 matrix
    - IsNode(*[2]/*/*/*,'simple')         # IsNode() returns true if all the nodes are simple
  variables: [IsColumnSilent: $ClearSpeak_Matrix != 'SpeakColNum']
  replace: 
    - t: the
    - x: count(*[2]/*)
    - t: by
    - x: count(*[2]/*[self::m:mtr][1]/*)
    - test:
        if: "*[1][text()='|']"    # just need to check the first bracket since we know it must be (, [, or |
        then: {t: determinant}
        else: {t: matrix}
    - pause: long
    - x: "*[2]/*"
    - test:
       if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
       then:
         - t: end
         - test:
            if: "*[1][text()='|']"    # just need to check the first bracket since we know it must be (, [, or |
            then: {t: determinant}
            else: {t: matrix}
 
-
   name: default-matrix
   tag: mrow
   variables: [IsColumnSilent: $ClearSpeak_Matrix = 'SilentColNum']
   match:
   - "*[2][self::m:mtable] and"
   - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|'))
   replace: 
    - t: the
    - x: "count(*[2]/*)"
    - t: by
    - x: "count(*[2]/*[self::m:mtr][1]/*)"
    - test:
        if: "*[1][text()='|']"    # just need to check the first bracket since we know it must be (, [, or |
        then: {t: determinant}
        else: {t: matrix}
    - pause: long
    - x: "*[2]/*"
    - test:
       if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
       then:
         - t: end
         - test:
            if: "*[1][text()='|']"    # just need to check the first bracket since we know it must be (, [, or |
            then: {t: determinant}
            else: {t: matrix}
-
  name: default
  tag: [mtr, mlabeledtr]
  match: "."
  replace:
   - t: row
   - x: "count(preceding-sibling::*)+1"
   - test:
      if: .[self::m:mlabeledtr]
      then:
         - t: with label
         - x: "*[1]/*"
         - pause: short
   - pause: medium
   - test:
      if: .[self::m:mlabeledtr]
      then: [x: "*[position()>1]"]
      else: {x: "*"}
-
  name: default
  tag: mtd
  match: "."
  replace:
   - test: 
   #  ClearSpeak normally speaks "column 1" even though it says the row number, which is a waste...
   #  The following is commented out but the count(...)!=0 probably belongs in other rule sets
   #   if: not($IsColumnSilent) and ($ClearSpeak_Matrix = 'SpeakColNum' or count(preceding-sibling::*) != 0)
      if: "not($IsColumnSilent)"
      then:
         - t: column
         - x: "count(preceding-sibling::*)+1"
         - pause: medium
   - x: "*"
   - test:
      # short pause after each element; medium pause if last element in a row; long pause for last element in matrix
      - if: count(following-sibling::*) > 0
        then: {pause: short}
      - else_if: count(../following-sibling::*) > 0
        then: {pause: medium}
        else: {pause: long}
 

-  # handle both log and ln
   name: log
   tag: mrow
   variables: [log_is_simple: "IsNode(*[3],'simple')"]
   match:
      - "count(*)=3 and"
      - "*[1][self::m:mi][text()='log' or text()='ln'] and"
      - "*[2][self::m:mo][text()='\u2061']"
   replace:
      - test:
         if: "$log_is_simple"
         then_test:
            - if: "*[1][text()='log']"
              then: [t: log]
            - else_if: $ClearSpeak_Log = 'LnAsNaturalLog'
              then: [t: natural log]
              else: [spell: ln]
         else:
          - test: 
             if: "$Verbosity!='Terse' and not(log_is_simple)"
             then: {t: the}
          - test:
            - if: "*[1][text()='log']"
              then: [t: log]
            - else_if: $ClearSpeak_Log = 'LnAsNaturalLog'
              then: [t: natural log]
              else: [spell: ln]
          - t: of
          - pause: short
      - x: "*[3]"

-
   name: ClearSpeak_Functions_None
   tag: mo
   match:
      - "text()='\u2061' and $ClearSpeak_Functions = 'None' and"
      - not(preceding-sibling::*[1][IsNode(., 'trig_name')]) # Functions=None does not apply to "trig" functions
   replace: 
      test:
         if: "$ClearSpeak_ImpliedTimes = 'None'"
         then: [t: ""]
         else: [t: times]

-
   name: no-times
   tag: mo
   match:
      # Note: this rule is also part of the paren rule so that the parens speak
      - "text()='\u2062' and $ClearSpeak_ImpliedTimes = 'None'"
   replace:
      - t: ""
   
-
   name: times
   tag: mo
   match:
      # say "times" when invisible times is followed by parens or a superscript that has a base with parens or "|"s
      - "text()='\u2062' and ("
      - "  $ClearSpeak_ImpliedTimes = 'MoreImpliedTimes'"
      - " or "
      - "  following-sibling::*[1][" 
      - "    IsBracketed(., '(', ')') or IsBracketed(., '[(]', ']') or IsBracketed(., '|', '|') or "  # followed by parens
      - "    ( (self::m:msup or self::m:msub or self::m:msubsup) and "                                # followed by msup, etc.
      - "       *[1][self::m:mrow][IsBracketed(., '(', ')') or IsBracketed(., '[(]', ']') or IsBracketed(., '|', '|')]"  # base has parens
      - "    )"
      - "  ]"
       # other possibility is the preceding element has parens (but not the following)
       # this is not mentioned in the ClearSpeak rules or examples but seems like it should say "times". E.g, |x| y
      - " or "  
      - "  preceding-sibling::*[1][" 
      - "    IsBracketed(., '(', ')') or IsBracketed(., '[(]', ']') or IsBracketed(., '|', '|')]"  # followed by parens
      - " )"
   replace:
      - t: times

-
   name: no-say-parens
   tag: mrow
   match:
      - "parent::*[not(self::m:msup) and not(self::m:msub) and not(self::m:msubsup)] and "
      - "( IsBracketed(., '(', ')') or IsBracketed(., '[', ']') ) and "
      - "not( $ClearSpeak_Functions = 'None' and "
      - "     (preceding-sibling::*[1][text()='\u2061'] or following-sibling::*[1][text()='\u2061']) ) and "
      - "not( $ClearSpeak_ImpliedTimes = 'None' and "
      - "     (preceding-sibling::*[1][text()='\u2062'] or following-sibling::*[1][text()='\u2062']) ) and "
      - "( IsNode(*[2], 'simple')  )"
         # missing clause: 'a positive fraction that is spoken as an ordinal
         #   (either by the Ordinal preference or by the default rules)'
   replace:
      - x: "*[2]"

-
   include: "default-rules.yaml"